using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.IdentityModel.Tokens.Jwt;
using System.Linq;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;
using EatFitAI.Domain.Entities;
using EatFitAI.Infrastructure.Auth;
using EatFitAI.Infrastructure.Persistence;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.Tokens;

namespace EatFitAI.Api.Controllers;

[ApiController]
[Route("api/auth")]
public class AuthController : ControllerBase
{
    private const int MaxFailedAccessAttempts = 5;
    private static readonly TimeSpan LockoutDuration = TimeSpan.FromMinutes(15);
    private readonly EatFitAiDbContext _db;
    private readonly IPasswordHasher _passwordHasher;
    private readonly IConfiguration _configuration;
    private readonly ILogger<AuthController> _logger;
    private readonly JwtSecurityTokenHandler _tokenHandler = new();
    private readonly TimeSpan _accessTokenLifetime;
    private readonly TimeSpan _refreshTokenLifetime;
    private readonly string _jwtKey;
    private readonly string? _jwtIssuer;
    private readonly string? _jwtAudience;

    public AuthController(
        EatFitAiDbContext db,
        IPasswordHasher passwordHasher,
        IConfiguration configuration,
        ILogger<AuthController> logger)
    {
        _db = db;
        _passwordHasher = passwordHasher;
        _configuration = configuration;
        _logger = logger;

        _jwtKey = _configuration["Jwt:Key"] ?? _configuration["Jwt__Key"]
                  ?? throw new InvalidOperationException("Missing JWT signing key (Jwt__Key).");
        _jwtIssuer = _configuration["Jwt:Issuer"] ?? _configuration["Jwt__Issuer"];
        _jwtAudience = _configuration["Jwt:Audience"] ?? _configuration["Jwt__Audience"];
        _accessTokenLifetime = ResolveAccessLifetime(_configuration);
        _refreshTokenLifetime = ResolveRefreshLifetime(_configuration);
    }

    [HttpPost("register")]
    [ProducesResponseType(typeof(AuthResponse), StatusCodes.Status201Created)]
    public async Task<ActionResult<AuthResponse>> Register([FromBody] RegisterRequest request, CancellationToken cancellationToken)
    {
        if (!ModelState.IsValid)
        {
            return ValidationProblemFromModelState();
        }

        var normalizedEmail = NormalizeEmail(request.Email);

        if (await _db.NguoiDungs.AnyAsync(u => u.Email == normalizedEmail, cancellationToken))
        {
            return Problem(
                statusCode: StatusCodes.Status409Conflict,
                title: "Email already registered",
                detail: "The provided email address is already associated with an account.");
        }

        var user = new NguoiDung
        {
            MaNguoiDung = Guid.NewGuid(),
            Email = normalizedEmail,
            MatKhauHash = _passwordHasher.HashPassword(request.Password),
            HoTen = string.IsNullOrWhiteSpace(request.Name) ? null : request.Name!.Trim(),
            AccessFailedCount = 0,
            LockoutEnd = null,
            NgayTao = DateTime.UtcNow,
            NgayCapNhat = DateTime.UtcNow,
        };

        _db.NguoiDungs.Add(user);

        var (accessToken, accessExpiresAt, jwtId) = CreateAccessToken(user);
        var refreshToken = CreateRefreshToken(user, jwtId, GetClientIp());
        _db.RefreshTokens.Add(refreshToken);

        await using var transaction = await _db.Database.BeginTransactionAsync(cancellationToken);
        await _db.SaveChangesAsync(cancellationToken);
        await transaction.CommitAsync(cancellationToken);

        var response = BuildAuthResponse(user, accessToken, accessExpiresAt, refreshToken);
        return CreatedAtAction(nameof(Me), new { }, response);
    }

    [HttpPost("login")]
    [ProducesResponseType(typeof(AuthResponse), StatusCodes.Status200OK)]
    public async Task<ActionResult<AuthResponse>> Login([FromBody] LoginRequest request, CancellationToken cancellationToken)
    {
        if (!ModelState.IsValid)
        {
            return ValidationProblemFromModelState();
        }

        var normalizedEmail = NormalizeEmail(request.Email);
        var user = await _db.NguoiDungs.SingleOrDefaultAsync(u => u.Email == normalizedEmail, cancellationToken)
                   ?? await _db.NguoiDungs.SingleOrDefaultAsync(u => u.Email == request.Email, cancellationToken);

        if (user is null)
        {
            return InvalidCredentialsProblem();
        }

        if (IsAccountLocked(user))
        {
            var remaining = user.LockoutEnd!.Value - DateTimeOffset.UtcNow;
            var detail = remaining > TimeSpan.Zero
                ? $"Account locked due to multiple failed attempts. Try again in {Math.Ceiling(remaining.TotalMinutes)} minutes."
                : "Account is temporarily locked. Please try again later.";
            return Problem(
                statusCode: StatusCodes.Status423Locked,
                title: "Account locked",
                detail: detail,
                type: "https://datatracker.ietf.org/doc/html/rfc4918#section-11.3");
        }

        if (!VerifyPassword(user, request.Password))
        {
            user.AccessFailedCount += 1;
            if (user.AccessFailedCount >= MaxFailedAccessAttempts)
            {
                user.LockoutEnd = DateTimeOffset.UtcNow.Add(LockoutDuration);
            }
            user.NgayCapNhat = DateTime.UtcNow;
            await _db.SaveChangesAsync(cancellationToken);
            _logger.LogWarning("Invalid credentials for user {Email}", user.Email);
            return InvalidCredentialsProblem();
        }

        user.AccessFailedCount = 0;
        user.LockoutEnd = null;
        user.NgayCapNhat = DateTime.UtcNow;

        var (accessToken, accessExpiresAt, jwtId) = CreateAccessToken(user);
        var refreshToken = CreateRefreshToken(user, jwtId, GetClientIp());
        _db.RefreshTokens.Add(refreshToken);

        await using var transaction = await _db.Database.BeginTransactionAsync(cancellationToken);
        await _db.SaveChangesAsync(cancellationToken);
        await transaction.CommitAsync(cancellationToken);

        var response = BuildAuthResponse(user, accessToken, accessExpiresAt, refreshToken);
        return Ok(response);
    }

    [HttpPost("refresh")]
    [ProducesResponseType(typeof(AuthResponse), StatusCodes.Status200OK)]
    public async Task<ActionResult<AuthResponse>> Refresh([FromBody] RefreshRequest request, CancellationToken cancellationToken)
    {
        if (!ModelState.IsValid)
        {
            return ValidationProblemFromModelState();
        }

        var tokenValue = request.RefreshToken.Trim();
        if (tokenValue.Length == 0)
        {
            return ValidationProblem(new ValidationProblemDetails(new Dictionary<string, string[]>
            {
                ["refreshToken"] = new[] { "Refresh token is required." }
            })
            {
                Status = StatusCodes.Status422UnprocessableEntity,
                Title = "Validation error",
                Type = "https://datatracker.ietf.org/doc/html/rfc4918#section-11.2"
            });
        }

        var storedToken = await _db.RefreshTokens.SingleOrDefaultAsync(rt => rt.Token == tokenValue, cancellationToken);
        if (storedToken is null)
        {
            return UnauthorizedTokenProblem("Refresh token is invalid.");
        }

        var now = DateTimeOffset.UtcNow;
        var clientIp = GetClientIp();

        if (storedToken.RevokedAt is not null)
        {
            await RevokeAllActiveTokens(storedToken.MaNguoiDung, "reuse-detected", clientIp, cancellationToken);
            return UnauthorizedTokenProblem("Refresh token has already been used.");
        }

        if (storedToken.ExpiresAt <= now)
        {
            storedToken.RevokedAt = now;
            storedToken.RevokedByIp = clientIp;
            storedToken.RevokedReason = "expired";
            await _db.SaveChangesAsync(cancellationToken);
            return UnauthorizedTokenProblem("Refresh token has expired.");
        }

        var user = await _db.NguoiDungs.SingleOrDefaultAsync(u => u.MaNguoiDung == storedToken.MaNguoiDung, cancellationToken);
        if (user is null)
        {
            storedToken.RevokedAt = now;
            storedToken.RevokedByIp = clientIp;
            storedToken.RevokedReason = "user-deleted";
            await _db.SaveChangesAsync(cancellationToken);
            return UnauthorizedTokenProblem("User associated with the refresh token no longer exists.");
        }

        var (accessToken, accessExpiresAt, jwtId) = CreateAccessToken(user);
        var newRefreshToken = CreateRefreshToken(user, jwtId, clientIp);

        storedToken.RevokedAt = now;
        storedToken.RevokedByIp = clientIp;
        storedToken.RevokedReason = "rotated";
        storedToken.ReplacedByToken = newRefreshToken.Token;

        user.NgayCapNhat = DateTime.UtcNow;
        _db.RefreshTokens.Add(newRefreshToken);

        await using var transaction = await _db.Database.BeginTransactionAsync(cancellationToken);
        await _db.SaveChangesAsync(cancellationToken);
        await transaction.CommitAsync(cancellationToken);

        var response = BuildAuthResponse(user, accessToken, accessExpiresAt, newRefreshToken);
        return Ok(response);
    }

    [HttpPost("google")]
    [ProducesResponseType(typeof(AuthResponse), StatusCodes.Status200OK)]
    public async Task<ActionResult<AuthResponse>> GoogleLogin([FromBody] GoogleLoginRequest request, CancellationToken cancellationToken)
    {
        if (!ModelState.IsValid)
        {
            return ValidationProblemFromModelState();
        }

        var validation = ValidateGoogleToken(request.IdToken);
        if (!validation.IsValid)
        {
            return Problem(
                statusCode: StatusCodes.Status401Unauthorized,
                title: "Google token invalid",
                detail: validation.Error ?? "Unable to validate Google id_token.");
        }

        var email = NormalizeEmail(validation.Email!);
        var user = await _db.NguoiDungs.SingleOrDefaultAsync(u => u.Email == email, cancellationToken);

        if (user is null)
        {
            user = new NguoiDung
            {
                MaNguoiDung = Guid.NewGuid(),
                Email = email,
                HoTen = validation.Name,
                MatKhauHash = _passwordHasher.HashPassword(Guid.NewGuid().ToString("N")),
                AccessFailedCount = 0,
                LockoutEnd = null,
                NgayTao = DateTime.UtcNow,
                NgayCapNhat = DateTime.UtcNow,
            };
            _db.NguoiDungs.Add(user);
        }
        else
        {
            user.HoTen ??= validation.Name;
            user.AccessFailedCount = 0;
            user.LockoutEnd = null;
            user.NgayCapNhat = DateTime.UtcNow;
        }

        var (accessToken, accessExpiresAt, jwtId) = CreateAccessToken(user);
        var refreshToken = CreateRefreshToken(user, jwtId, GetClientIp());
        _db.RefreshTokens.Add(refreshToken);

        await using var transaction = await _db.Database.BeginTransactionAsync(cancellationToken);
        await _db.SaveChangesAsync(cancellationToken);
        await transaction.CommitAsync(cancellationToken);

        var response = BuildAuthResponse(user, accessToken, accessExpiresAt, refreshToken);
        return Ok(response);
    }

    [Authorize]
    [HttpGet("me")]
    [ProducesResponseType(typeof(AuthUser), StatusCodes.Status200OK)]
    public async Task<ActionResult<AuthUser>> Me(CancellationToken cancellationToken)
    {
        var subject = User.FindFirstValue(JwtRegisteredClaimNames.Sub);
        if (!Guid.TryParse(subject, out var userId))
        {
            return Unauthorized();
        }

        var user = await _db.NguoiDungs.FindAsync(new object[] { userId }, cancellationToken);
        if (user is null)
        {
            return NotFound();
        }

        return Ok(new AuthUser(user.MaNguoiDung.ToString(), user.Email, user.HoTen));
    }

    private static TimeSpan ResolveAccessLifetime(IConfiguration configuration)
    {
        var minutesStr = configuration["Jwt:AccessTokenMinutes"] ?? configuration["Jwt__AccessTokenMinutes"];
        return int.TryParse(minutesStr, out var minutes) && minutes > 0
            ? TimeSpan.FromMinutes(minutes)
            : TimeSpan.FromMinutes(15);
    }

    private static TimeSpan ResolveRefreshLifetime(IConfiguration configuration)
    {
        var daysStr = configuration["Jwt:RefreshTokenDays"] ?? configuration["Jwt__RefreshTokenDays"];
        return int.TryParse(daysStr, out var days) && days > 0
            ? TimeSpan.FromDays(days)
            : TimeSpan.FromDays(7);
    }

    private static string NormalizeEmail(string email) => email.Trim().ToLowerInvariant();

    private static bool IsAccountLocked(NguoiDung user) =>
        user.LockoutEnd.HasValue && user.LockoutEnd.Value > DateTimeOffset.UtcNow;

    private (string Token, DateTimeOffset ExpiresAt, string JwtId) CreateAccessToken(NguoiDung user)
    {
        var now = DateTimeOffset.UtcNow;
        var expiresAt = now.Add(_accessTokenLifetime);
        var jwtId = Guid.NewGuid().ToString("N");

        var claims = new List<Claim>
        {
            new(JwtRegisteredClaimNames.Sub, user.MaNguoiDung.ToString()),
            new(JwtRegisteredClaimNames.Email, user.Email),
            new(JwtRegisteredClaimNames.Jti, jwtId)
        };

        if (!string.IsNullOrWhiteSpace(user.HoTen))
        {
            claims.Add(new("name", user.HoTen!));
        }

        var keyBytes = Encoding.UTF8.GetBytes(_jwtKey);
        var signingCredentials = new SigningCredentials(new SymmetricSecurityKey(keyBytes), SecurityAlgorithms.HmacSha256);

        var token = new JwtSecurityToken(
            issuer: _jwtIssuer,
            audience: _jwtAudience,
            claims: claims,
            notBefore: now.UtcDateTime,
            expires: expiresAt.UtcDateTime,
            signingCredentials: signingCredentials);

        var tokenString = _tokenHandler.WriteToken(token);
        return (tokenString, expiresAt, jwtId);
    }

    private RefreshToken CreateRefreshToken(NguoiDung user, string jwtId, string? clientIp)
    {
        return new RefreshToken
        {
            MaNguoiDung = user.MaNguoiDung,
            Token = GenerateSecureToken(),
            JwtId = jwtId,
            ExpiresAt = DateTimeOffset.UtcNow.Add(_refreshTokenLifetime),
            CreatedAt = DateTimeOffset.UtcNow,
            CreatedByIp = clientIp
        };
    }

    private AuthResponse BuildAuthResponse(NguoiDung user, string accessToken, DateTimeOffset accessExpiresAt, RefreshToken refreshToken)
    {
        var authUser = new AuthUser(user.MaNguoiDung.ToString(), user.Email, user.HoTen);
        var tokens = new AuthTokens(
            accessToken,
            accessExpiresAt,
            refreshToken.Token,
            refreshToken.ExpiresAt);
        return new AuthResponse(authUser, tokens);
    }

    private async Task RevokeAllActiveTokens(Guid userId, string reason, string? ipAddress, CancellationToken cancellationToken)
    {
        var now = DateTimeOffset.UtcNow;
        var tokens = await _db.RefreshTokens
            .Where(rt => rt.MaNguoiDung == userId && rt.RevokedAt == null)
            .ToListAsync(cancellationToken);

        if (tokens.Count == 0)
        {
            return;
        }

        foreach (var token in tokens)
        {
            token.RevokedAt = now;
            token.RevokedByIp = ipAddress;
            token.RevokedReason = reason;
        }

        await _db.SaveChangesAsync(cancellationToken);
    }

    private bool VerifyPassword(NguoiDung user, string password)
    {
        try
        {
            if (_passwordHasher.VerifyPassword(password, user.MatKhauHash))
            {
                return true;
            }
        }
        catch (CryptographicException)
        {
            // fall through to legacy check
        }

        if (user.MatKhauHash.Length == 32)
        {
            var legacyHash = SHA256.HashData(Encoding.UTF8.GetBytes(password));
            if (legacyHash.AsSpan().SequenceEqual(user.MatKhauHash))
            {
                user.MatKhauHash = _passwordHasher.HashPassword(password);
                return true;
            }
        }

        return false;
    }

    private (bool IsValid, string? Email, string? Name, string? Error) ValidateGoogleToken(string idToken)
    {
        if (string.IsNullOrWhiteSpace(idToken))
        {
            return (false, null, null, "id_token is required.");
        }

        if (!_tokenHandler.CanReadToken(idToken))
        {
            return (false, null, null, "id_token format is invalid.");
        }

        var token = _tokenHandler.ReadJwtToken(idToken);
        var email = token.Claims.FirstOrDefault(c => c.Type == JwtRegisteredClaimNames.Email || c.Type == "email")?.Value;
        if (string.IsNullOrWhiteSpace(email))
        {
            return (false, null, null, "Google token missing email claim.");
        }

        var audience = token.Audiences.FirstOrDefault();
        var expectedAudiences = new[]
        {
            _configuration["Auth__Google__ClientId_Web"],
            _configuration["Auth__Google__ClientId_Android"]
        }.Where(v => !string.IsNullOrWhiteSpace(v)).ToHashSet(StringComparer.Ordinal);

        if (expectedAudiences.Count > 0 && (audience is null || !expectedAudiences.Contains(audience)))
        {
            return (false, null, null, "Google token audience does not match configured client IDs.");
        }

        var name = token.Claims.FirstOrDefault(c => c.Type == "name")?.Value;
        return (true, email, name, null);
    }

    private string? GetClientIp()
    {
        return HttpContext.Connection.RemoteIpAddress?.ToString();
    }

    private ActionResult ValidationProblemFromModelState()
    {
        var errors = ModelState
            .Where(entry => entry.Value?.Errors.Count > 0)
            .ToDictionary(
                entry => entry.Key,
                entry => entry.Value!.Errors.Select(e => string.IsNullOrWhiteSpace(e.ErrorMessage) ? "Invalid value." : e.ErrorMessage).ToArray());

        var problem = new ValidationProblemDetails(errors)
        {
            Status = StatusCodes.Status422UnprocessableEntity,
            Title = "Validation error",
            Type = "https://datatracker.ietf.org/doc/html/rfc4918#section-11.2"
        };

        return ValidationProblem(problem);
    }

    private ActionResult<AuthResponse> InvalidCredentialsProblem()
    {
        return Problem(
            statusCode: StatusCodes.Status401Unauthorized,
            title: "Invalid credentials",
            detail: "Email or password is incorrect.");
    }

    private ActionResult<AuthResponse> UnauthorizedTokenProblem(string detail)
    {
        return Problem(
            statusCode: StatusCodes.Status401Unauthorized,
            title: "Refresh token rejected",
            detail: detail);
    }

    private static string GenerateSecureToken()
    {
        Span<byte> buffer = stackalloc byte[64];
        RandomNumberGenerator.Fill(buffer);
        return Convert.ToBase64String(buffer);
    }

    public sealed record class RegisterRequest
    {
        [Required, EmailAddress]
        public string Email { get; init; } = string.Empty;

        [Required, MinLength(8)]
        public string Password { get; init; } = string.Empty;

        [MaxLength(150)]
        public string? Name { get; init; }
    }

    public sealed record class LoginRequest
    {
        [Required, EmailAddress]
        public string Email { get; init; } = string.Empty;

        [Required]
        public string Password { get; init; } = string.Empty;
    }

    public sealed record class RefreshRequest
    {
        [Required]
        public string RefreshToken { get; init; } = string.Empty;
    }

    public sealed record class GoogleLoginRequest
    {
        [Required]
        public string IdToken { get; init; } = string.Empty;
    }

    public sealed record AuthUser(string Id, string Email, string? Name);

    public sealed record AuthTokens(
        string AccessToken,
        DateTimeOffset AccessTokenExpiresAt,
        string RefreshToken,
        DateTimeOffset RefreshTokenExpiresAt);

    public sealed record AuthResponse(AuthUser User, AuthTokens Tokens);
}
